package draft

import (
	"encoding/json"
	"strings"
	"testing"
	"time"
)

func TestRenderReportMarkdown(t *testing.T) {
	report := createTestReport()

	md, err := RenderReportMarkdown(report)
	if err != nil {
		t.Fatalf("RenderReportMarkdown failed: %v", err)
	}

	// Verify required sections are present
	requiredSections := []string{
		"# Legislative Impact Report:",
		"**Risk Level:",
		"## Executive Summary",
		"## Structural Changes",
		"## Conflict Findings",
		"## Temporal Analysis",
		"---",
		"*Generated by regula",
	}

	for _, section := range requiredSections {
		if !strings.Contains(md, section) {
			t.Errorf("Markdown output missing required section: %s", section)
		}
	}

	// Verify table formatting
	if !strings.Contains(md, "| Type | Target | Description |") {
		t.Error("Markdown output missing structural changes table header")
	}

	// Verify bill info is present
	if !strings.Contains(md, "Test Act of 2026") {
		t.Error("Markdown output missing bill title")
	}
	if !strings.Contains(md, "H.R. 1234") {
		t.Error("Markdown output missing bill number")
	}

	t.Logf("Markdown output length: %d characters", len(md))
}

func TestRenderReportMarkdown_EmptyReport(t *testing.T) {
	// Test with minimal report
	report := &LegislativeImpactReport{
		GeneratedAt: time.Now(),
		RiskLevel:   RiskLow,
		ExecutiveSummary: ExecutiveSummary{
			BillTitle:  "Empty Bill",
			BillNumber: "H.R. 0000",
		},
	}

	md, err := RenderReportMarkdown(report)
	if err != nil {
		t.Fatalf("RenderReportMarkdown failed for empty report: %v", err)
	}

	// Should still have basic structure
	if !strings.Contains(md, "# Legislative Impact Report:") {
		t.Error("Empty report missing title")
	}
	if !strings.Contains(md, "**Risk Level: LOW**") {
		t.Error("Empty report missing risk level")
	}
	if !strings.Contains(md, "## Executive Summary") {
		t.Error("Empty report missing executive summary")
	}

	// Should NOT have these sections (no data)
	if strings.Contains(md, "## Structural Changes") {
		t.Error("Empty report should not have structural changes section")
	}
	if strings.Contains(md, "## Conflict Findings") {
		t.Error("Empty report should not have conflict findings section")
	}
}

func TestRenderReportMarkdown_NilReport(t *testing.T) {
	md, err := RenderReportMarkdown(nil)
	if err == nil {
		t.Error("Expected error for nil report")
	}
	if md != "" {
		t.Error("Expected empty string for nil report")
	}
}

func TestRenderReportJSON(t *testing.T) {
	report := createTestReport()

	jsonStr, err := RenderReportJSON(report)
	if err != nil {
		t.Fatalf("RenderReportJSON failed: %v", err)
	}

	// Verify it's valid JSON
	var parsed map[string]interface{}
	if err := json.Unmarshal([]byte(jsonStr), &parsed); err != nil {
		t.Fatalf("Invalid JSON output: %v", err)
	}

	// Verify key fields are present
	requiredFields := []string{
		"bill",
		"generated_at",
		"risk_level",
		"executive_summary",
		"diff",
		"conflicts",
		"temporal_findings",
	}

	for _, field := range requiredFields {
		if _, ok := parsed[field]; !ok {
			t.Errorf("JSON output missing required field: %s", field)
		}
	}

	// Verify round-trip: unmarshal back into struct
	var roundTripped LegislativeImpactReport
	if err := json.Unmarshal([]byte(jsonStr), &roundTripped); err != nil {
		t.Fatalf("Failed to unmarshal JSON back to struct: %v", err)
	}

	if roundTripped.ExecutiveSummary.BillNumber != report.ExecutiveSummary.BillNumber {
		t.Error("Round-trip failed: bill number mismatch")
	}
	if roundTripped.RiskLevel != report.RiskLevel {
		t.Error("Round-trip failed: risk level mismatch")
	}

	t.Logf("JSON output length: %d characters", len(jsonStr))
}

func TestRenderReportJSON_NilReport(t *testing.T) {
	jsonStr, err := RenderReportJSON(nil)
	if err == nil {
		t.Error("Expected error for nil report")
	}
	if jsonStr != "" {
		t.Error("Expected empty string for nil report")
	}
}

func TestRenderReportJSON_Timestamps(t *testing.T) {
	report := &LegislativeImpactReport{
		GeneratedAt: time.Date(2026, 2, 15, 14, 30, 0, 0, time.UTC),
		RiskLevel:   RiskLow,
	}

	jsonStr, err := RenderReportJSON(report)
	if err != nil {
		t.Fatalf("RenderReportJSON failed: %v", err)
	}

	// Verify timestamp is in RFC3339 format
	if !strings.Contains(jsonStr, "2026-02-15T14:30:00Z") {
		t.Error("Timestamp not in expected RFC3339 format")
	}
}

func TestRenderReportHTML(t *testing.T) {
	report := createTestReport()

	htmlStr, err := RenderReportHTML(report)
	if err != nil {
		t.Fatalf("RenderReportHTML failed: %v", err)
	}

	// Verify HTML structure
	requiredElements := []string{
		"<!DOCTYPE html>",
		"<html",
		"<head>",
		"<style>",
		"</style>",
		"<body>",
		"</body>",
		"</html>",
	}

	for _, elem := range requiredElements {
		if !strings.Contains(htmlStr, elem) {
			t.Errorf("HTML output missing required element: %s", elem)
		}
	}

	// Verify content sections
	contentSections := []string{
		"<h1>Legislative Impact Report:",
		"<h2>Executive Summary</h2>",
		"<h2>Structural Changes</h2>",
		"<h2>Conflict Findings</h2>",
		"<h2>Temporal Analysis</h2>",
	}

	for _, section := range contentSections {
		if !strings.Contains(htmlStr, section) {
			t.Errorf("HTML output missing content section: %s", section)
		}
	}

	// Verify bill info is escaped properly
	if !strings.Contains(htmlStr, "Test Act of 2026") {
		t.Error("HTML output missing bill title")
	}

	// Verify CSS is inline (no external dependencies)
	if strings.Contains(htmlStr, "<link rel=\"stylesheet\"") {
		t.Error("HTML should not have external CSS links")
	}
	if strings.Contains(htmlStr, "<script src=") {
		t.Error("HTML should not have external script sources")
	}

	t.Logf("HTML output length: %d characters", len(htmlStr))
}

func TestRenderReportHTML_NilReport(t *testing.T) {
	htmlStr, err := RenderReportHTML(nil)
	if err == nil {
		t.Error("Expected error for nil report")
	}
	if htmlStr != "" {
		t.Error("Expected empty string for nil report")
	}
}

func TestRenderReportHTML_RiskColors(t *testing.T) {
	tests := []struct {
		name      string
		riskLevel RiskLevel
		cssClass  string
		label     string
	}{
		{"high risk", RiskHigh, "risk-high", "HIGH RISK"},
		{"medium risk", RiskMedium, "risk-medium", "MEDIUM RISK"},
		{"low risk", RiskLow, "risk-low", "LOW RISK"},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			report := &LegislativeImpactReport{
				GeneratedAt: time.Now(),
				RiskLevel:   tc.riskLevel,
				ExecutiveSummary: ExecutiveSummary{
					BillTitle: "Risk Test Bill",
				},
			}

			htmlStr, err := RenderReportHTML(report)
			if err != nil {
				t.Fatalf("RenderReportHTML failed: %v", err)
			}

			// Check for correct CSS class
			if !strings.Contains(htmlStr, tc.cssClass) {
				t.Errorf("HTML output missing risk class: %s", tc.cssClass)
			}

			// Check for correct label
			if !strings.Contains(htmlStr, tc.label) {
				t.Errorf("HTML output missing risk label: %s", tc.label)
			}
		})
	}
}

func TestRenderReportHTML_HTMLEscaping(t *testing.T) {
	// Test with special characters that need escaping
	report := &LegislativeImpactReport{
		GeneratedAt: time.Now(),
		RiskLevel:   RiskLow,
		ExecutiveSummary: ExecutiveSummary{
			BillTitle:         "Test <script>alert('xss')</script> Bill",
			RiskJustification: "Contains \"quotes\" & <special> characters",
		},
	}

	htmlStr, err := RenderReportHTML(report)
	if err != nil {
		t.Fatalf("RenderReportHTML failed: %v", err)
	}

	// Script tags should be escaped
	if strings.Contains(htmlStr, "<script>alert") {
		t.Error("HTML output contains unescaped script tag")
	}

	// Should contain escaped version
	if !strings.Contains(htmlStr, "&lt;script&gt;") {
		t.Error("HTML output missing escaped script tag")
	}

	// Quotes and ampersands should be escaped
	if strings.Contains(htmlStr, "\"quotes\" & <special>") {
		t.Error("HTML output contains unescaped special characters")
	}
}

func TestRenderReportHTML_SelfContained(t *testing.T) {
	report := createTestReport()

	htmlStr, err := RenderReportHTML(report)
	if err != nil {
		t.Fatalf("RenderReportHTML failed: %v", err)
	}

	// Should not have any external resource references
	externalPatterns := []string{
		"href=\"http",
		"href=\"https",
		"src=\"http",
		"src=\"https",
		"@import url",
	}

	for _, pattern := range externalPatterns {
		if strings.Contains(htmlStr, pattern) {
			t.Errorf("HTML output contains external resource reference: %s", pattern)
		}
	}
}

func TestRenderReportMarkdown_Visualization(t *testing.T) {
	report := &LegislativeImpactReport{
		GeneratedAt:   time.Now(),
		RiskLevel:     RiskLow,
		Visualization: "digraph G { A -> B; }",
	}

	md, err := RenderReportMarkdown(report)
	if err != nil {
		t.Fatalf("RenderReportMarkdown failed: %v", err)
	}

	// Should include visualization section with code block
	if !strings.Contains(md, "## Impact Visualization") {
		t.Error("Markdown missing visualization section")
	}
	if !strings.Contains(md, "```dot") {
		t.Error("Markdown missing DOT code block")
	}
	if !strings.Contains(md, "digraph G { A -> B; }") {
		t.Error("Markdown missing visualization content")
	}
}

func TestRenderReportHTML_Visualization(t *testing.T) {
	report := &LegislativeImpactReport{
		GeneratedAt:   time.Now(),
		RiskLevel:     RiskLow,
		Visualization: "digraph G { A -> B; }",
	}

	htmlStr, err := RenderReportHTML(report)
	if err != nil {
		t.Fatalf("RenderReportHTML failed: %v", err)
	}

	// Should include visualization section
	if !strings.Contains(htmlStr, "<h2>Impact Visualization</h2>") {
		t.Error("HTML missing visualization section")
	}
	// Should be in a collapsible details element
	if !strings.Contains(htmlStr, "<details>") {
		t.Error("HTML missing details element for visualization")
	}
	// Should have the DOT content
	if !strings.Contains(htmlStr, "digraph G") {
		t.Error("HTML missing visualization content")
	}
}

func TestRenderReportMarkdown_RiskLevelEmojis(t *testing.T) {
	tests := []struct {
		level RiskLevel
		emoji string
	}{
		{RiskHigh, "ðŸ”´"},
		{RiskMedium, "ðŸŸ "},
		{RiskLow, "ðŸŸ¢"},
	}

	for _, tc := range tests {
		t.Run(tc.level.String(), func(t *testing.T) {
			report := &LegislativeImpactReport{
				GeneratedAt: time.Now(),
				RiskLevel:   tc.level,
			}

			md, err := RenderReportMarkdown(report)
			if err != nil {
				t.Fatalf("RenderReportMarkdown failed: %v", err)
			}

			if !strings.Contains(md, tc.emoji) {
				t.Errorf("Expected emoji %s for risk level %s", tc.emoji, tc.level)
			}
		})
	}
}

func TestFormatTitlesForMarkdown(t *testing.T) {
	tests := []struct {
		titles   []int
		expected string
	}{
		{nil, ""},
		{[]int{}, ""},
		{[]int{15}, "15"},
		{[]int{11, 42, 47}, "11, 42, 47"},
	}

	for _, tc := range tests {
		result := formatTitlesForMarkdown(tc.titles)
		if result != tc.expected {
			t.Errorf("formatTitlesForMarkdown(%v) = %q, want %q", tc.titles, result, tc.expected)
		}
	}
}

func TestFormatTargetForMarkdown(t *testing.T) {
	tests := []struct {
		amendment Amendment
		expected  string
	}{
		{
			Amendment{TargetTitle: "15", TargetSection: "6502"},
			"15 U.S.C. Â§ 6502",
		},
		{
			Amendment{TargetTitle: "42", TargetSection: "247d", TargetSubsection: "a"},
			"42 U.S.C. Â§ 247d(a)",
		},
	}

	for _, tc := range tests {
		result := formatTargetForMarkdown(tc.amendment)
		if result != tc.expected {
			t.Errorf("formatTargetForMarkdown() = %q, want %q", result, tc.expected)
		}
	}
}

func TestTruncateMarkdown(t *testing.T) {
	tests := []struct {
		text     string
		maxLen   int
		expected string
	}{
		{"short", 10, "short"},
		{"this is a longer string", 10, "this is..."},
		{"exact len", 9, "exact len"},
		{"text\nwith\nnewlines", 20, "text with newlines"},
	}

	for _, tc := range tests {
		result := truncateMarkdown(tc.text, tc.maxLen)
		if result != tc.expected {
			t.Errorf("truncateMarkdown(%q, %d) = %q, want %q", tc.text, tc.maxLen, result, tc.expected)
		}
	}
}

// createTestReport builds a comprehensive test report with all sections populated.
func createTestReport() *LegislativeImpactReport {
	return &LegislativeImpactReport{
		Bill: &DraftBill{
			BillNumber: "H.R. 1234",
			ShortTitle: "Test Act of 2026",
			Congress:   "119th",
			Sections: []*DraftSection{
				{
					Number: "1",
					Title:  "Short Title",
					Amendments: []Amendment{
						{Type: AmendStrikeInsert, TargetTitle: "15", TargetSection: "6502"},
						{Type: AmendRepeal, TargetTitle: "42", TargetSection: "247d"},
					},
				},
			},
		},
		GeneratedAt: time.Date(2026, 2, 15, 10, 30, 0, 0, time.UTC),
		RiskLevel:   RiskMedium,
		ExecutiveSummary: ExecutiveSummary{
			BillTitle:               "Test Act of 2026",
			BillNumber:              "H.R. 1234",
			AmendmentCount:          2,
			TitlesAffected:          []int{15, 42},
			ProvisionsModified:      1,
			ProvisionsRepealed:      1,
			ProvisionsAdded:         0,
			TotalProvisionsAffected: 15,
			BrokenCrossRefs:         2,
			ConflictErrors:          0,
			ConflictWarnings:        1,
			ObligationsAdded:        1,
			ObligationsRemoved:      0,
			RightsAdded:             0,
			RightsRemoved:           1,
			RiskLevel:               RiskMedium,
			RiskJustification:       "1 conflict warning(s); 2 broken cross-reference(s)",
		},
		Diff: &DraftDiff{
			Modified: []DiffEntry{
				{
					Amendment:        Amendment{Type: AmendStrikeInsert, TargetTitle: "15", TargetSection: "6502", Description: "Modify privacy requirements"},
					TargetURI:        "https://regula.dev/US-USC-TITLE-15:Art6502",
					TargetDocumentID: "us-usc-title-15",
				},
			},
			Removed: []DiffEntry{
				{
					Amendment:        Amendment{Type: AmendRepeal, TargetTitle: "42", TargetSection: "247d", Description: "Repeal obsolete provision"},
					TargetURI:        "https://regula.dev/US-USC-TITLE-42:Art247d",
					TargetDocumentID: "us-usc-title-42",
				},
			},
		},
		Conflicts: &ConflictReport{
			Conflicts: []Conflict{
				{
					Type:        ConflictObligationOrphaned,
					Severity:    ConflictWarning,
					Description: "Repealing Art247d orphans obligation depended on by Art248",
				},
			},
			Summary: ConflictSummary{
				TotalConflicts: 1,
				Warnings:       1,
			},
		},
		TemporalFindings: []TemporalFinding{
			{
				Type:        TemporalGap,
				Severity:    ConflictWarning,
				Description: "Section 247d is repealed with no apparent replacement",
			},
		},
		Impact: &DraftImpactResult{
			DirectlyAffected: []AffectedProvision{
				{URI: "https://regula.dev/US-USC-TITLE-15:Art6503", Label: "Art6503", Depth: 1, Reason: "references modified Art6502"},
			},
			TransitivelyAffected: []AffectedProvision{
				{URI: "https://regula.dev/US-USC-TITLE-15:Art6504", Label: "Art6504", Depth: 2, Reason: "transitively linked via Art6503"},
			},
			BrokenCrossRefs: []BrokenReference{
				{SourceURI: "https://regula.dev/US-USC-TITLE-42:Art248", SourceLabel: "Art248", TargetURI: "https://regula.dev/US-USC-TITLE-42:Art247d", TargetLabel: "Art247d", Severity: SeverityError, Reason: "target repealed"},
				{SourceURI: "https://regula.dev/US-USC-TITLE-15:Art6510", SourceLabel: "Art6510", TargetURI: "https://regula.dev/US-USC-TITLE-15:Art6502", TargetLabel: "Art6502", Severity: SeverityWarning, Reason: "target substantially modified"},
			},
			TotalProvisionsAffected: 15,
		},
	}
}
